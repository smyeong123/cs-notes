# Tree
모든 Tree 유형을 알아보겠다.

## 기본 용어
간략하게 Tree에 쓰이는 용어에 대해 살펴 보겠다.
- Node (노드): 각 데이터를 저장하는 원소다.
    - Root Node (뿌리 노드): 부모가 없는 최상위 노드다. 트리는 하나의 뿌리 노드를 가지며, 시작하는 지점이라 봐도 무방하다.
    - Child Node (자식 노드): 부모 노드에 연결된 **하위 노드** 다. 
    - Parent Node (부모 노드): 자식 노드를 가진 노드다.
    - Leaf Node (리프 노드): 자식 노드가 없는 노드다.
    - Internal Node (내부 노드): 뿌리나 리프 노드가 아닌 노드다.
- Branch (가지): 두 노드를 연결하는 선이며, edge, 또는 link 라고도 불린다.
- Height (높이): 뿌리 노드로 부터 가장 먼 리프 노드까지의 거리이다.
- Level (레벨): 뿌리 노드로부터 해당 노드까지의 거리이다. 뿌리 노드의 레벨은 0이다.
- Sub-Tree (서브 트리): 특정 노드를 루트로 하는 하위 트리. 

## Binary Tree (이진 트리)
이진 트리는 자식 노드가 최대 2개를 가지고 있는 트리다. 원소를 삽입할떄 자식 노드가 두개이면 리프노드의 자식 노드로 추가를 한다.
### Full Binary Tree
모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리이다.
### Complete Binary Tree
모든 레벨이 꽉 차 있고 마지막 레벨은 왼쪽부터 채워진 트리이다.
### Perfect Binary Tree
모든 내부 노드가 두 개의 자식 노드를 가지고, 모든 리프 노드가 동일한 레벨에 존재하는 트리이다.
### Balanced Binary Tree
모든 리프 노드의 깊이가 비슷하여 트리의 높이가 최소화된 트리이다.
## Binary Search Tree (BST, 이진 탐색 트리)

다음과 같은 특징을 유지한다.

$ \text{왼쪽 자식 노드 값} \leq \text{부모 노드 값} \leq \text{오른쪽 자식 노드 값}$
### Adelson-Velsky and Landis (AVL) Tree
- BST의 속성을 유지한다.
- 각 노드의 **왼쪽과 오른쪽 서브 트리 높이 차이**가 1 이하가 되도록 자동으로 회전을 통해 **균형(balance)**을 유지한다.
- **시간 복잡도**:
  - 탐색, 삽입, 삭제: $O(\log n)$

### Segment Tree
- 구간 합, 최소/최대값 등 **범위 쿼리(range query)**를 빠르게 처리하는 트리 구조를 가지고 있다.
- 배열의 구간 정보를 저장하여 쿼리와 업데이트를 $O(\log n)$에 처리 가능하다.
### Red Black Tree
- BST의 균형을 유지하기 위한 **자기 균형 이진 탐색 트리**이다.
- 각 노드는 빨간색 또는 검은색으로 이루어져 있다.
- 다음과 같은 속성을 유지한다:
  - 루트는 항상 검정
  - 빨간 노드의 자식은 모두 검정
  - 루트에서 리프까지 가는 모든 경로에 같은 수의 검정 노드가 있음
- 시간 복잡도: 삽입, 삭제, 탐색 $O(\log n)$
## B-Tree & B+ Tree

### B-Tree
- 균형 잡힌 **다진 검색 트리(multi-way search tree)**이다.
- 한 노드가 **여러 개의 키와 자식 포인터**를 가질 수 있어 디스크 접근이 잦은 환경에 적합하다.
- 루트에서 리프까지의 거리가 짧다.

### B+ Tree
- B-Tree에서 파생된 구조다.
- **모든 데이터는 리프 노드에만 저장**한다
- 리프 노드 간 **포인터로 연결되어 순차 접근에 효율적**이다
- 인덱스 구조에 자주 쓰인다. (MySQL)
