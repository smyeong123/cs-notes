# SORTING

해당 노트는 모든 정렬 알고리즘의 정리다.

## Selection Sort (선택 정렬)
선택 정렬은 배열에서 최소 또는 최대값을 반복적으로 찾아 정렬하는 방식이다.
매우 직관적인 알고리즘이며, 시간 복잡도는 $O(n^2)$이다.

장점: 구현이 간단하고, 교환 횟수가 적을 때 상대적으로 효율적이다.

적용 시점: 데이터 크기가 매우 작을 때 적용한다.

데이터 크기가 매우 작을때 효율적이고, 교환 횟수가 적을때 효율적이다.
## Bubble Sort (버블 정렬)
버블 정렬은 리스트를 여러 번 순회하면서 인접한 두 원소를 비교하고 교환하는 방식이다.
시간 복잡도는 $O(n^2)$이고, 특히 배열이 거의 정렬된 경우 빠르게 정렬된다.

장점: 구현이 매우 간단하고, 정렬 여부를 직관적으로 확인할 수 있다.

적용 시점: 데이터가 거의 정렬된 상태일 때 효율적이이다.
## Insertion Sort (삽입 정렬)
삽입 정렬은 배열의 각 원소를 이미 정렬된 부분에 적절한 위치에 삽입해 나가며 정렬한한다.
평균 시간 복잡도는 $O(n^2)$, 정렬된 배열에 대해서는 최선의 경우 $O(n)$이다.

장점: 안정된 정렬방법법이며, 거의 정렬된 데이터에 매우 빠르다.

적용 시점: 거의 정렬된 배열에서 버블 정렬보다 더 효율적이다.
## Merge Sort (병합 정렬)
분할 정복(Divide and Conquer) 방식으로 작동하며, 배열을 반으로 나눈 뒤 각각 정렬하고 병합합니다.
항상 시간 복잡도는 $O(n \log n)$이다.

장점: 성능이 항상 안정적이며 일관됨.

적용 시점: 데이터 크기가 크고, 안정성이 필요한 경우 적합하하다.


## Quick Sort (퀵 정렬)
퀵 정렬도 병합 정렬처럼 분할 정복 기법을 사용하지만, Pivot을 기준으로 배열을 분할한다.
평균 시간 복잡도는 $O(n \log n)$, 최악의 경우는 $O(n^2)$이다

장점: 실제로 가장 빠른 정렬 알고리즘 중 하나이며, 추가 메모리가 거의 필요 없다.

적용 시점: 랜덤하게 분포된 데이터에 효과적이며, 최악의 경우를 피하려면 무작위 Pivot 선택이 권장된다.
## Heap Sort (힙 정렬)

힙 자료구조(최대 힙/최소 힙)를 활용해 데이터를 정렬하는 방식입니다.
시간 복잡도는 항상 $O(n \log n)$이며, 불안정한 정렬방법이다.

장점: 성능이 일정하며, 추가 메모리 공간이 거의 필요 없다.

적용 시점: 일정한 성능 보장이 필요하거나, 메모리 사용을 최소화해야 할 때 유용하다.

